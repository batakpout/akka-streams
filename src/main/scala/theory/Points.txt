--> Akka Streams allows Stream Processing, Stream processing allows us to model data manipulation as a flow of data.
--> Akka Streams implements Reactive Stream standards.
--> Reactive Stream Standard: Reactive Stream is an initiative to provide a standard for asynchronous stream
    processing with non-blocking back pressure.
--> alpakka connects akka-streams to other technologies and tries to apply the same properties to those
    technologies. "Alpakka- endpoints for akka streams". We have alpakka connectors for cloud services
    (aws, google cloud, azure), data sources (cassandra, hadoop, elasticsearch, mongo etc) and
    messaging (apache kafka, RabbitMQ, MQTT, JMS (java messaging service) etc)
--> A different area in alpakka is data-transformations, we go from one format method to another
    (e.g JSON, csv, xml etc)

--> Design asynchronous, back-pressured, incremental, potentially infinite data processing systems. (known as Reactive Streams)
--> Reactive streams is an SPI (service provider interface), not an API. Akka Streams are API
--> Specification of async, back-pressured streams.
    publisher (emits elements async), subscriber (receives elements),
    processor (transforms elements along the way)

    --> Components/Operators of akka-stream (source, flow, sink)

--> data flows async. (async op. is evaluated or executed at no well defined time) and this is done without blocking
    any running code.

--> Source emits elements asynchronously, may or may not terminate
    A Source is a set of stream processing steps that has one open output.
    It can comprise any number of internal sources and transformations that are wired together,
     or it can be an “atomic” source, e.g. from a collection or a file.
     Materialization turns a Source into a Reactive Streams Publisher (at least conceptually).
--> Sink terminates only when Source terminates.
--> Flow (processor) transforms elements
--> We building streams by connecting (Source, Flow, Sink)
--> Direction: Upstream(to the source), downstream (to the sink)

--> Actor-Materializer: In principle it allows running of akka stream components

--> Sources can emit any kind of objects, as long as they are immutable and serializable, nulls are not allowed
--> Materializing:
    -> Components are static until they are run
    --> run(), i.e running a graph, allocates right resources(actor, thread, socket etc) and gives us single materialized value
    --> Running a Graph = Materializing a graph
    --> Materializing a graph = materializing all components
    --> Materializing a Graph = materializing all components i.e
    --> each component produces a materialized value when running a graph, but its up to us which materialized
        value to take. The result of running graph is a single materialized value
    --> A component can materialize multiple times
    --> you can use the same component in different graphs
    --> different runs = different materialization
    --> A materialized value can be ANYTHING(connecting to some service, unit, Future, 32 anything)
    --> A materialized value may or may not have any connection at all to the actual elements that go through the stream
    --> ActorMaterializer("") Objects that allocates the right resources to running an Akka Stream
