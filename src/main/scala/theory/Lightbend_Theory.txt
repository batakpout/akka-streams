==What are streams====
--> Streams are sequences of data, divided up into individual elements
--> The size of the stream may not be known, or may be infinite
--> Often streams are too large to fit in memory
    Examples:
    Twitter "firehose" of tweets
    Live video streams
    Data from a fitness tracker

--> Use cases for Streams:
    Consuming Live events (e.g tweets)
    ETL systems (Extract, Transform, Load)
    Streaming media(audio, video)

====Reactive Streams===
--> Reactive Steams is an initiative to provide a standard for asynchronous stream processing with
    non-blocking back pressure. This encompasses efforts aimed at runtime environments (JVM & JavaScript)
    as well as network protocols

--> Why Reactive Streams?
    How can we consume a stream of data in an asynchronous fashion?
    How can we prevent an asynchronous stream from overwhelming a slow consumer?
    How can we maintain ordering guarantees even while processing things asynchronously?

-> Reactive Stream Components:
   Publisher: Publishes data into stream
   Subscriber: Consumers data from stream
   Processor: Acts as both a publisher and a subscriber, obeying the contract for each
   Subscription: Connects a Subscriber to a Publisher in order to initiate the message flow

   -----BackPressure-------
   Backpressure implemented using a pull/push mechanism, Subscribers signal demand. Demand is sent
   upstream via subscription.
   Publisher is forbidden from send the data downstream until the demand has been signalled.
   Publishers receive demand and push data (if available) downstream.
   Publisher are forbidden from pushing more than the demand.

  -----Akka Streams relation to Reactive Streams-------
  Akka Streams is build on the concepts and interfaces of Reactive Streams but provides an API
  that is geared towards the end-users.
  Exposes some points for interoperability between Reactive Streams and Akka Streams.

  -----Akka Streams relationship to akka Actors---------
  Actors consume stream of data in the form of messages
  It can be tedious(dull/boring) and error prone to implement streams with backpressure between actor manually.
  Akka Streams provides a higher level API for stream processing, backed by akka actors
  Akka Streams provide statically typed guarantees that prevent wiring errors

--> What is an Akka Stream?
    Data flows through a chain of processing stages.
    Stages consist of zero or more input and zero or more output.
    Stages must have atleast one input or output.
    By default, stages are fused together to run synchronously inside a single actor, but can be made
    to run asynchronously in separate actors.

    Sources - The "source" of the data in the stream.
    Sinks - The "destinations" for the data in the stream.
    Flows - Transformations to the data in the stream.
    Runnable Graphs - A stream where all inputs and outputs are connected.

    Each stage in the stream can be executed synchronously or asynchronously.
    In most cases, element order is preserved.
    Backpressure is propagated from downstream stages to upstream.
    Linear stream are often sufficient for most use cases.

   Graph introduce Junctions - Branch points in the stream(fan-out, fan-in).
   Graphs allow us to build complex flow of data with multiple inputs and outputs.

   Sources/Flows/Sinks/Junctions are immutable, re-useable templates.
   They contain instruction on how to produce/transform/consume data.
   By themselves they do nothing.
   In order to start the flow of data, the graph must first be materialized.

   implicit val materializer = ActorMaterializer()
   Materialization is the act of allocating resources to the stream.
   occurs when all the stages in the stream are connected and the steam is run.
   Running the stream results in Materialized values being produced.
   Each stage is capable of producing a single materialized value.
   Materialized Values are separate from the elements being produced/transformed/consumed by the stages.
   An Implicit materialized is required.

   case Study: AkkaAssembly- model a simple automobile factory [receive parts:- assemble cars,
    paint them and finally run them through an inspection.]

=== Sources =====
--> A Source is a stage with a single output.
--> Think of it as an input to the stream
--> Could be receiving data from a file, database, a REST API, collection etc.
--> Amount of data in the source is not pre-determined. It may be infinite.
--> Define as Source[+Out, +Mat]
    Out defines the type of the elements that the Source Produces.
    Mat defines the type of materialized value.
--> Sources receive Demand from downstream.
--> A Source can push data downstream, as long as there is demand.
--> If there is no demand, then the source is forbidden from pushing data.
--> The source has to deal with in-comming data until demand resumes,
    maybe slow down consumption of data: reject data from REST API, or buffer it, or drop it,
    depends on type of Source we have.
--> Sources respond to demand in an onPull handler.
--> May also respond to onDownStreamFinish.
--> In response to an onPull request, the Source may:
    - push data downstream
    - complete the stream with a success
    - fail the stream with an error
    - do nothing
--> There logic is implemented for a variety of different sources.
--> val source: Source[String, NotUsed] = Source.empty[String]
    - empty stream of specified type, always completes the stream
    - used mostly for testing, how system behaves when there is no data.
    - if else expression, return empty from else to maintain type, cool!
--> Source.single("Hello world"), push a single element whenever there is demand and then complete.
--> Source.repeat("Hello world"), push a single same element infinitely whenever there is demand.
--> Source.tick(initialDelay, interval, tick):Same element is infinitely pushed whenever there is demand
    if there is no demand, (i.e backpressure), no tick will be pushed, that tick will be lost. etc

===Sinks=====
--> A Sink is a stage with single input.
--> It's output of the stream, could be writing to a file, database, REST API, collection etc.
--> Sink create backpressure by controlling Demand. A sink can only send Demand when it is ready to receive
    more data, If a sink can not keep up with incomming data, demand will stop and the data flow will cease.
--> Sink[-In, +Mat]: In is the type of element Sink Consumes, Mat is type of the materialized value.
--> Sinks respond to new data in an onPush handler, in response to onPush request, the sink may:
    request new data from upstream using pull, grab any data that has already been pushed, cancel the
    stream causing it to termination. This logic is implemented for variety of different sinks.
--> Sink[Any, Future[Done]] = Sink.ignore: pulls all elements in the stream and discards them without processing.
--> Sink.head[Int]/last:  pulls until it finding the first or last element in stream and materializes it.

====Flow=====
--> A flow is a graph with single input and single output.
--> A flows acts as both a Source and Sink, obeying the rules for both.
--> A flow receives demand from downstream and propogates it upstream.
--> Flows can propogate backpressure upstream by reducing or stopping demand.
--> Alternatively Flows can drop data, buffer data etc.
--> A Flow is both a consumer and a producer. It uses the message flow of both Source and Sink.
--> It may respond to both onPush and onPull. It responds with the same messages as Source and Sink.
--> val flow: Flow[Int, Int, NotUsed] = Flow[Int].buffer(100, OverflowStrategy.backpressure)
    buffer buffers incomming message in order to smooth out inconsistencies in flow rates.
    
--> Flows for slow consumers/ produers:
    - expand: extrapolates additional values from the incomming elements to fill gaps when the 
      consumer is faster than the producer.
    - batch: group elements in a batch to be consumed downstream if the producer is faster than the consumer.
    - conflate: create a summary of multiple elements to be consumed downstream if the producer is faster than the consumer.

=====Runnable Graphs=====================
--> Connect all inputs and outputs in Source/Sink/Flows, to create a Runnable Graph.
--> Once a Runnable Graph is created, the data can start flowing.

=======Graphs=================
--> Graphs introduce the concept of Junctions. Sources/Sinks/Flows are graph elements with a single input and/or single output.
--> Junctions allow for multiple inputs/outputs.
--> Basic Junction types are fan-in and fan-out.
--> fan-out:
    Broadcast[T] - Incomming elements are emitted to all outputs. (1 input, N output), 
    Balance[T] - Incomming elements are emitted to one of the outputs(first available) - (1 input, N outputs)
    UnzipWith[In, A, B] -(1 input, N output): Uses a function to convert 1 input element into N outputs elements and emits one to each output.
    Unzip[A, B] - (1 input, 2 output)- splits a stream of Tuple2[A, B] into two streams of A and B
    
--> fan-int:
    Merge[Int] = N inputs, 1 output) - randomly selects from inputs and pushes to a single output.
    MergePreferred[Int] - (N inputs, 1 output) similar to merge, but one input is given higher priority over all others. if data comes in on that input,
    it will push the data , before looking at any other inputs.
    ZipWith[A, B,..., Out] - (N inputs, 1 output) Uses a function to take one element from each input and convert them all to a single output.
    Zip[A, B] - (2 inputs, 1 output) - Zips two streams of A and B into a single stream of TUple2[A, B]
    Concat[A] - (2 inputs, 1 output) concatenates two streams. Consumes one completely before the other.
    
--> A Graph DSL is provided to simply the creation of complex graphs. Designed to make it easier to translate drawing into code.
--> import GraphDSL.Implicits._ to enable the DSL
--> Partial Graphs/Open Graphs (return SourceShape(merge.out)) can be created in the shape of Linear Graph Elements (e.g Source/Sink/Flow)
--> Some predefined shapes exist to allow for easier graph construction.
    Linear Shapes (SourceShape, SinkShape, FlowShape)
    Junction Shapes with the same input/input types UniformFanInShape, UniformFanOutShape 
    Junction Shapes with different input/output types:
    FanInShape1, FanInShape2....FanInShape22
    FanOutShape1, FanOutShape2....FanOutShape22   
    
--> A simpler API exists for cases where your graph needs are small. Source.combine combines two ore more sources using the provided Fan In Shape
--> Sink.combine- combines two or more Sinks into a single Sink using the provided Fan Out Shape.

==========Operator Fusion===================
--> Crossing asynchronous boundaries can be an expensive operation.
--> By default, akka streams "fuses" all processing stages into a single synchronous stage.
--> Requires an element to be processed fully before the next element starts i.e from source to sink, end-to-end, boring...
--> This can be disabled by setting akka.stream.materializer.auto-fusing=off
--> Stages often make use of a small buffer. Buffers are not present when a stage is fused. i.e ran on single thread
--> The buffers can result in different behaviour in your stream.
--> Adding an asynchronous boundary will introduce the buffer.

--> we add async boundary to prevent fusion from happening.
--> Async boundaries create overhead in the form of: Actors, mailboxes, Buffers.
--> Important: Introducing Asynchrony is not a magical bullet. Depending on the performance characteristics of your stage it may provide little or no
     benefit. Understanding your implementation is key.
     
--> The general principles of Fusion optimization are:
    - To improve performance in our stream we need to take the longest fused portion and insert an asynchronous boundary.
    - We insert an async boundary to bisect the stream into two subsections of roughly equal processing time.
    -For example, imagine that the longest fused portion of the Factory RunnableGraph stage busy times is:
   	...paint)           // busy(5.millis)
	...installEngine)   // busy(5.millis)
	...installWheels)   // busy(5.millis)
	...installUpgrades) // busy(5.millis)
	Thus bisect the fused stream as follows:
	...paint)           // busy(5.millis)
	...installEngine)   // busy(5.millis)
	BISECT
	...installWheels)   // busy(5.millis)
	...installUpgrades) // busy(5.millis)
	
--> Where this is not feasible, we try to get as close as we can.
	In our case, we start with a single fused section that we want to partition.
	...paint)           // busy(2.millis)
	...installEngine)   // busy(2.millis)
	...installWheels)   // busy(10.millis)
	...installUpgrades) // busy(2.millis)
	Due to the 10 ms busy time on the installWheels, we can't bisect the stream into two equal halves, 
	so instead we aim for 4 ms on one side of the async boundary and 12 ms on the other. That's the closest we can get to an equal stream bisection with the 		current setup.

--> General principles of Fusion optimization - using two async boundaries we tested this.
	-To improve performance in our stream we need to take the longest fused portion and insert an asynchronous boundary.
	-We insert an async boundary to bisect the stream into two subsections of roughly equal processing time.
	- Where this is not feasible, we try to get as close as we can.
	- Once we have bisected the stream into two subsections, try to further bisect the new longest fused section.
	- Repeat this process until the longest section can't be broken down or bisected further.
	- Note:  You are always limited by the processing time of the longest fused section. So if one section takes 10 ms, then partitioning a section that only 			takes 4 ms won't provide significant benefit.
	- Note:  For lower throughput streams, the overhead of an asynchronous boundary may be insignificant. In this case, putting asynchronous boundaries 		everywhere may not hurt (but also may not help). 
	However, for high throughput streams, the overhead may exceed the benefit and could actually slow down your stream.
	
--> Best Practice: Understand the performance of your stream and measure the impact of your asynchronous boundaries.
    If you would like, you may introduce additional asynchronous boundaries to test whether you can see any more improvement. However, due to the structure of    	the stream and that the longest section of 10 ms can't be bisected further, any additional benefits should be insignificant.





