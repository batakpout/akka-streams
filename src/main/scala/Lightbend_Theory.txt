==What are streams====
--> Streams are sequences of data, divided up into individual elements
--> The size of the stream may not be known, or may be infinite
--> Often streams are too large to fit in memory
    Examples:
    Twitter "firehose" of tweets
    Live video streams
    Data from a fitness tracker

--> Use cases for Streams:
    Consuming Live events (e.g tweets)
    ETL systems (Extract, Transform, Load)
    Streaming media(audio, video)

====Reactive Streams===
--> Reactive Steams is an initiative to provide a standard for asynchronous stream processing with
    non-blocking back pressure. This encompasses efforts aimed at runtime environments (JVM & JavaScript)
    as well as network protocols

--> Why Reactive Streams?
    How can we consume a stream of data in an asynchronous fashion?
    How can we prevent an asynchronous stream from overwhelming a slow consumer?
    How can we maintain ordering guarantees even while processing things asynchronously?

-> Reactive Stream Components:
   Publisher: Publishes data into stream
   Subscriber: Consumers data from stream
   Processor: Acts as both a publisher and a subscriber, obeying the contract for each
   Subscription: Connects a Subscriber to a Publisher in order to initiate the message flow

   -----BackPressure-------
   Backpressure implemented using a pull/push mechanism, Subscribers signal demand. Demand is sent
   upstream via subscription.
   Publisher is forbidden from send the data downstream until the demand has been signalled.
   Publishers receive demand and push data (if available) downstream.
   Publisher are forbidden from pushing more than the demand.

  -----Akka Streams relation to Reactive Streams-------
  Akka Streams is build on the concepts and interfaces of Reactive Streams but provides an API
  that is geared towards the end-users.
  Exposes some points for interoperability between Reactive Streams and Akka Streams.

  -----Akka Streams relationship to akka Actors---------
  Actors consume stream of data in the form of messages
  It can be tedious(dull/boring) and error prone to implement streams with backpressure between actor manually.
  Akka Streams provides a higher level API for stream processing, backed by akka actors
  Akka Streams provide statically typed guarantees that prevent wiring errors

--> What is an Akka Stream?
    Data flows through a chain of processing stages.
    Stages consist of zero or more input and zero or more output.
    Stages must have atleast one input or output.
    By default, stages are fused together to run synchronously inside a single actor, but can be made
    to run asynchronously in separate actors.

    Sources - The "source" of the data in the stream.
    Sinks - The "destinations" for the data in the stream.
    Flows - Transformations to the data in the stream.
    Runnable Graphs - A stream where all inputs and outputs are connected.

    Each stage in the stream can be executed synchronously or asynchronously.
    In most cases, element order is preserved.
    Backpressure is propagated from downstream stages to upstream.
    Linear stream are often sufficient for most use cases.

   Graph introduce Junctions - Branch points in the stream(fan-out, fan-in).
   Graphs allow us to build complex flow of data with multiple inputs and outputs.

   Sources/Flows/Sinks/Junctions are immutable, re-useable templates.
   They contain instruction on how to produce/transform/consume data.
   By themselves they do nothing.
   In order to start the flow of data, the graph must first be materialized.

   implicit val materializer = ActorMaterializer()
   Materialization is the act of allocating resources to the stream.
   occurs when all the stages in the stream are connected and the steam is run.
   Running the stream results in Materialized values being produced.
   Each stage is capable of producing a single materialized value.
   Materialized Values are separate from the elements being produced/transformed/consumed by the stages.
   An Implicit materialized is required.

   case Study: AkkaAssembly- model a simple automobile factory [receive parts:- assemble cars,
    paint them and finally run them through an inspection.]

=== Sources =====
--> A Source is a stage with a single output.
--> Think of it as an input to the stream
--> Could be receiving data from a file, database, a REST API, collection etc.
--> Amount of data in the source is not pre-determined. It may be infinite.
--> Define as Source[+Out, +Mat]
    Out defines the type of the elements that the Source Produces.
    Mat defines the type of materialized value.
--> Sources receive Demand from downstream.
--> A Source can push data downstream, as long as there is demand.
--> If there is no demand, then the source is forbidden from pushing data.
--> The source has to deal with in-comming data until demand resumes,
    maybe slow down consumption of data: reject data from REST API, or buffer it, or drop it,
    depends on type of Source we have.
--> Sources respond to demand in an onPull handler.
--> May also respond to onDownStreamFinish.
--> In response to an onPull request, the Source may:
    - push data downstream
    - complete the stream with a success
    - fail the stream with an error
    - do nothing
--> There logic is implemented for a variety of different sources.
--> val source: Source[String, NotUsed] = Source.empty[String]
    - empty stream of specified type, always completes the stream
    - used mostly for testing, how system behaves when there is no data.
    - if else expression, return empty from else to maintain type, cool!
--> Source.single("Hello world"), push a single element whenever there is demand and then complete.
--> Source.repeat("Hello world"), push a single same element infinitely whenever there is demand.
--> Source.tick(initialDelay, interval, tick):Same element is infinitely pushed whenever there is demand
    if there is no demand, (i.e backpressure), no tick will be pushed, that tick will be lost. etc

===Sinks=====
--> A Sink is a stage with single input.
--> It's output of the stream, could be writing to a file, database, REST API, collection etc.
--> Sink create backpressure by controlling Demand. A sink can only send Demand when it is ready to receive
    more data, If a sink can not keep up with incomming data, demand will stop and the data flow will cease.
--> Sink[-In, +Mat]: In is the type of element Sink Consumes, Mat is type of the materialized value.
--> Sinks respond to new data in an onPush handler, in response to onPush request, the sink may:
    request new data from upstream using pull, grab any data that has already been pushed, cancel the
    stream causing it to termination. This logic is implemented for variety of different sinks.
--> Sink[Any, Future[Done]] = Sink.ignore: pulls all elements in the stream and discards them without processing.
--> Sink.head[Int]/last:  pulls until it finding the first or last element in stream and materializes it.

====Flow=====
--> A flow is a graph with single input and single output.
--> A flows acts as both a Source and Sink, obeying the rules for both.
--> A flow receives demand from downstream and propogates it upstream.
--> Flows can propogate backpressure upstream by reducing or stopping demand.
--> Alternatively Flows can drop data, buffer data etc.
--> A Flow is both a consumer and a producer. It uses the message flow of both Source and Sink.
--> It may respond to both onPush and onPull. It responds with the ame messages as Source and Sink.
--> val flow: Flow[Int, Int, NotUsed] = Flow[Int].buffer(100, OverflowStrategy.backpressure)
    buffer buffers incomming message in order to smooth out inconsistencies in flow rates.
    
--> Flows for slow consumers/ produers:
    - expand: extrapolates additional values from the incomming elements to fill gaps when the 
      consumer is faster than the producer.
    - batch: group elements in a batch to be consumed downstream if the producer is faster than the consumer.
    - conflate: create a summary of multiple elements to be consumed downstream if the producer is faster than the consumer.
    
    
    
    

